---
layout: post
title: jvm-GC
category: jvm
tags: jvm
description: GC
---

程序计数器，虚拟机栈，本地方法栈3个区域随线程而生，随线程而灭。

# 对象是否死忙

## 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效值就减1；任何时刻计数器为0的对象就不可能再被使用。


## 可达性分析算法（Reachability Analysis）
这个算法的基本思路就是通过一系列的成为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索锁走过的路径成为引用链（Reference Chain）,
当一个对象到GC Roots没有任何引用链相连时。
Java 中，可以作为GC Roots 的对象包括以下几种：
  虚拟机栈（栈帧中的本地变量表）中引用的对象。
  方法区中类静态属性引用的对象
  方法区中常量引用的对象
  本地方法栈中JNI(即一般说的Native的方法)引用的对象

# 引用
引用可分为强引用，软引用，弱引用，虚引用

## 强引用
就是指在代码之中普通存在的。类似`Object a = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

## 软引用
软引用用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常以前，将会把这些对象列进回收范围之中进行第二次回收。

## 弱引用
弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

## 虚引用
也成为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

# 算法

## 标记-清除算法
首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

## 复制算法
将可用内从按容量划分为相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面。然后再把已经使用过的内存空间一次性清理掉。这样使得每次都是对整个半区惊醒内存回收。内存分配时就不要考虑内存碎片等复杂问题。

现在的商业虚拟机都是采用这种手机算法来回收新生代，将内存分为一块较大的Eden空间，和两块较小的Suivivor空间，每次使用Eden和其中的一块Survivor.当回收时，将Eden和Survivor中还存活的对象一次性的复制到另外一块Survivor中，然后清理掉Eden和
刚才用过的Survivor。默认Eden 和 Survivor的比例为 8：1.这样只会有010%的空间被浪费。
## 标记-整理算法
标记整理算法和标记-清楚算法前面都一样，只是后面步骤不是直接将可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

# GC日志

```
[GC [PSYoungGen: 8192K->1005K(9216K)] 8192K->1450K(19456K), 0.0021430 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
```


```
Heap
 PSYoungGen      total 9216K, used 7326K [0x00000007ff600000, 0x0000000800000000, 0x0000000800000000)
  eden space 8192K, 77% used [0x00000007ff600000,0x00000007ffc32310,0x00000007ffe00000)
  from space 1024K, 95% used [0x00000007fff00000,0x00000007ffff5800,0x0000000800000000)
  to   space 1024K, 0% used [0x00000007ffe00000,0x00000007ffe00000,0x00000007fff00000)
 ParOldGen       total 10240K, used 4548K [0x00000007fec00000, 0x00000007ff600000, 0x00000007ff600000)
  object space 10240K, 44% used [0x00000007fec00000,0x00000007ff071098,0x00000007ff600000)
 PSPermGen       total 21504K, used 4581K [0x00000007f9a00000, 0x00000007faf00000, 0x00000007fec00000)
  object space 21504K, 21% used [0x00000007f9a00000,0x00000007f9e79748,0x00000007faf00000)

Process finished with exit code 0
```

PSYoungGen
如果使用ParNew收集器，新生代的名称为ParNew,意为 ‘Parallel New Generation’
如果使用Parallel Scavenge收集器，新生代的名称为PsYoungGen

PSPermGen
同上

ParOldGen
使用 ParallelOld收集器

# 内存分配策略

## 对象优先在Eden分配
堆内存分为 新生代和老年代
新生代分 Eden 和 Survivor
对象优先分配在Survivor

## 大对象直接进入老年代

```
-XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配
```

所谓的带对象是指大量连续内存空间的Java对象，最典型的就是长字符串以及数组。(尤其是`短命大对象`)
经常出现大对象容易导致内存还有不少空间就提前出发垃圾收集以获取足够的连续空间来安置他们

## 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个年龄（Age）计数器, 如果对象在Eden出生并经历第一次Minor GC后仍然存活，并且能被Survivor容纳,将被移动到Survivor空间中，并且兑现年龄设为1，
对象在Survivor空间没‘熬过’一次Minor GC，年龄就会增加一岁。当它的年龄增加到一定值（默认为15岁），将会被晋升到老年代中。
可以通过以下参数设置

```
-XX: MaxTenuringThreshold
```

## 动态对象年龄判断
为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的综合大于Survior空间的一半，
年龄大于或者等于该年龄的对象就可以直接进入老年代。无需等大搜MaxTenuringThreshold中要求的年龄

## 空间分配担保
在发生Minor Gc 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor Gc是可以确保安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否
允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均代销，如果大于会尝试一次Minor GC（如果失败了在Full GC），如果小于则会先Full GC然后再Minor GC。





