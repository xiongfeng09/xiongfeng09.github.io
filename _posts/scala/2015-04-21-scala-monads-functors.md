---
layout: post
title: scala-函数式编程
category: scala
tags: scala
description: scala functors monads
---

### 函数副作用

在计算机科学中，函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。
函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。严格的函数式语言要求函数必须无副作用。


### 纯函数 ( Pure Function )

输入输出数据流全是显式（Explicit）的。 显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部。函数输出到函数外部的所有信息都通过返回值传递到该函数外部。

显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。


### 非纯函数 ( Impure Function )

与之相反。 隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如读取/修改全局变量，都叫作以隐式的方式和外界进行数据交换。

隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如，读取全局变量，修改全局变量，都叫作以隐式的方式和外界进行数据交换；比如，利用I/O API（输入输出系统函数库）读取配置文件，或者输出到文件，打印到屏幕，都叫做隐式的方式和外界进行数据交换。


### 引用透明 ( Referential Transparent )

引用透明的概念与函数的副作用相关，且受其影响。 如果程序中两个相同值得表达式能在该程序的任何地方互相替换，而不影响程序的动作，那么该程序就具有引用透明性。它的优点是比非引用透明的语言的语义更容易理解，不那么晦涩。纯函数式语言没有变量，所以它们都具有引用透明性。

引用透明（Referential Transparent）的概念与函数的副作用相关，且受其影响。如果程序中任意两处具有相同输入值的函数调用能够互相置换，而不影响程序的动作，那么该程序就具有引用透明性。它的优点是比非引用透明的语言的语义更容易理解，不那么晦涩。纯函数式语言没有变量，所以它们都具有引用透明性。


范例

```
 f(x)
 {
   return x + 1
 }
```

f(x)函数就是纯函数。

```
 a = 0
 q(x) {
   b = a
 }
```

q(x)访问了函数外部的变量。q(x)是非纯函数。

```
 p(x){
   print“hello”
 }
```

p(x)通过I/O API输出了一个字符串。p(x)是非纯函数。


```
 c(x) {
   data = readConfig() // 读取配置文件
 }
```

c(x)通过I/O API读取了配置文件。c(x)是非纯函数。

纯函数内部有隐式（Implicit）的数据流，这种情况叫做副作用（Side Effect）。我们可以把副作用想象为潜规则。上述的I/O，外部变量等，都可以归为副作用。因此，纯函数的定义也可以写为，没有副作用的函数，叫做纯函数。

I/O API可以看作是一种特殊的全局变量。文件、屏幕、数据库等输入输出结构可以看作是独立于运行环境之外的系统外全局变量，而不是应用程序自己定义的全局变量。

### 特殊的函数副作用
上述只讨论了一般的情况，还有一种特殊的情况，我们没有讨论。有些函数的参数是一种In/Out作用的参数，即函数可能改变参数里面的内容，把一些信息通过输入参数，夹带到外界。这种情况，严格来说，也是副作用。也是非纯函数。 比如下面的函数。

```
 process(context) {
   a = context.getInfo()
   result = calculate(a)
   context.setResult(result)
}
```

### 纯函数的优点
纯函数的好处主要有几点：

无状态。线程安全。不需要线程同步。
纯函数相互调用组装起来的函数，还是纯函数。
应用程序或者运行环境（Runtime）可以对纯函数的运算结果进行缓存，运算加快速度。

### Wadler monad

Wadler: “一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？”

### 群

google到数学里定义的群(group): G为非空集合，如果在G上定义的二元运算 *，满足

```
  1.封闭性： 对于所有G中a, b，运算a·b的结果也在G中。b[›]
  2.结合性： 对于所有G中的a, b和c，等式 (a·b)·c = a· (b·c)成立。
  3.单位元： 存在G中的一个元素e，使得对于所有G中的元素a，等式e·a = a·e = a成立。
  4.逆元 ：  对于每个G中的a，存在G中的一个元素b使得a·b = b·a = e，这里的e是单位元。
```

则称（G，*）是群，简称G是群。

例：整数
最常见的群之一是整数集\mathbb{Z}，它由以下数组成：

..., −4, −3, −2, −1, 0, 1, 2, 3, 4, ...
下列整数加法的性质，可以作为抽象的群公理的模型。

对于任何两个整数a和b，它们的和a + b也是整数。换句话说，在任何时候，把两个整数相加都能得出整数的结果。这个性质叫做在加法下封闭。
对于任何整数a, b和c，(a + b) + c = a +（b + c）。用话语来表达，先把a加到b，然后把它们的和加到c，所得到的结果与把a加到b与c的和是相等的。这个性质叫做结合律。
如果a是任何整数，那么0 + a = a + 0 = a。零叫做加法的单位元，因为把它加到任何整数都得到相同的整数。
对于任何整数a，存在另一个整数b使得a + b = b + a = 0。整数b叫做整数a的逆元，记为−a。

### 半群
如果仅满足封闭性和结合律，则称G是一个半群（Semigroup）

### 幺半群
如果仅满足封闭性、结合律并且有幺元，则称G是一个含幺半群（Monoid）。

### 范畴
一个“范畴”C 是由如下3个数学实体所组成的：

1.一个类ob(C)，其元素称为“物件”；
2. 一个类hom(C)，其元素称为“态射”或“箭号”。每个态射f 都只有一个“源物件”a 及一个“目标物件”b（其中a 和b 都在ob(C) 内），称之为“从a 至b 的态射”，标记为f : a → b。
所有从a 至b 的态射所组成的类称之为“态射类”，标记为hom(a, b)、homC(a, b)、mor(a, b) 或C(a, b)。
3.一个二元运算，称为“态射复合”，使得对任意三个物件a、b 及c，都会有hom(b, c) × hom(a, b) → hom(a, c)。两个态射f : a → b 及g : b → c 的复合写做g ∘ f 或gf,[1]，并会符合下列两个公理：
结合律：若f : a → b、g : b → c及h : c → d，则h ∘ (g ∘ f) = (h ∘ g) ∘ f；
单位元：对任意物件x，总存在一个态射1x : x → x（称为x 的单位态射），使得对每个态射f : a → b，都会有1b ∘ f = f = f ∘ 1a。



### functor applicative monads
#### Functor
应用函数到封装过的值

```
val a: Optioin[Int] = *
a.map(_ + 1)
```

#### Applicative
应用封装过的函数到封装过的值

```
val a: Optioin[Int] = *
val func: Option[Int => Int] = *
a.flatMap { v=>
    func.map { f =>
        f(v)
    }
}
```


### Monads
应用会返回封装过的值的函数到封装过的值.

```
a.flatMap(getOptionByKey)
```

http://jiyinyiyong.github.io/monads-in-pictures/
http://zhuoqiang.me/what-is-monad.html
