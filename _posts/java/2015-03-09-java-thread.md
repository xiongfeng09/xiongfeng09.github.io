---
layout: post
title: java thread
category: java
tags: java
description: java 多线程
---

# 阿姆达尔定律
Amdahl

```
S=1/(1-a+a/n)
```

其中，a为并行计算部分所占比例，n为并行处理结点个数。
这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；
当a=0时（即只有串行，没有并行），最小加速比s=1；
当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。
例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式已被学术界所接受，并被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。

# 摩尔定律
摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。
其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。
换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。

# 进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

# 线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

Java线程分2类
1.用户线程，运行在前台，执行具体任务，如程序主线程、连接网络的子线程。
2.守护线程，运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随JVM一起

结束工作。如数据库连接池的监测线程、JVM虚拟机启动后的监测线程、垃圾回收线程

设置守护线程：
调用Thread类的setDaemon(true)方法设置当前线程为守护线程。
1.setDaemon(true)方法必须在start()方法签调用，否则会抛出IllegalThreadStateException异常
2.守护线程中产生的新线程也是守护线程
3.不是所有任务都可以分配给守护线程执行，如读写操作或计算逻辑。

# volatile
当一个变量定义为volatile之后，它将具备两种特性，
第一是保证此变量对所有线程的可见性，这里的`可见性`是指当一条线程修改了这个变量时，新值对于其它线程来说是可以立即得知的。

volatile 只能保证可见性不能保证原子性
所有它的使用场景如下
预算结果并不依赖变量的当前值，或者能够确保只有单一的县城修改变量值。
变量不需要与其它的状态变量共同参与不变约束。

# 原子性
java内存模型来直接保证的原子性变量操作包括read， load， assign， use， store 和 write
我们大致可以认为基本的数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定）
如果应用需要一个更大的原子性保证，java内存模型还提供了lock和unlock操作来满足这种需求，
尽管虚拟机没有把lock和unlock操作直接开房给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，
这两个字节码指令对应到java代码中就是同步块---synchronized关键字，因此synchronized关键字也具备原子性

# 可见性
可见性是指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。
java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。
volatile变量的特殊规则保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新，因此说volatile保证了多线程操作时变量的可见性。
除了volatile之外，Java还有两个关键字能实现可见性，synchronized 和 final
同步快的可见性是“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”
而final关键字的可见性是“被final修饰的字段在构造其中一旦初始化完成，其他线程就能看见final字段的值”

# 有序性
java语言提供了volatile和synchronized来保证有序性
valatile关键字本身就包含了禁止指令冲排序的语义
而synchronized则是“一个变量在一个时刻只允许一条线程对其进行lock操作”，这条规则决定了持有一个锁的两个同步快只能串行的进入。
