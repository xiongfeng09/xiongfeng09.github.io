---
layout: post
title: jvm-memory-architecture
category: jvm
tags: jvm
description: 内存区域
---

# 运行时数据区域

## 程序计数器
程序计数器（Program Counter Register） 是一个较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器。一个处理器（对于多核处理器来说是一个内核），都会执行一条线程的指令。
因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间互补影响，独立存储。即“线程私有”的内存

## java虚拟机栈
每个方法在执行的时候都会创建一个栈帧（Stack Frame）,用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
每个方法从调用到执行完成的过程，就会对应一个栈帧在虚拟机栈中的入栈和出栈的过程

## java本地方法栈
本地方法栈与虚拟机栈的区别在于，本地方法栈为虚拟机使用到Native方法服务

## java堆
java堆（java Heap）是java虚拟机所管理的内存中最大的一块。线程共享的一块内存区域，当虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在这里分配内存。

## 方法区
与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。

## 运行常量池
Class文件中除了类型的版本，字段，方法，接口等，还有一项就是常量池（Constant Pool Table）,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

# HotSpot虚拟机对象探秘

## 对象的创建
当虚拟机遇到一个new指令的时候，先查看指令的参数是否能够在常量池中定位到一个符号引用，并且检查这个符号引用代表的类是否被加载，解析，初始化。如果没有就加载
在类加载检查通过后，虚拟机将为新生对象分配内存。

### 分配内存的方式
1 假设java堆中的内存是完整的，所有分配过的内存都放一边。没有分配过的放另一边。中间有一个指针座位分界点的指示器。这种分配叫做`指针碰撞`（Bump the Pointer）
2 假设java对中的内存是不完整的， 虚拟机就需要维护一个列表用来记录哪些是用过的内存，哪些是没有用过的内存。这种分配叫做`空闲列表`(Free List)

## 对象的内存分布
对象在内存存储的布局可以分为3个区块： 对象头（Header）,实例数据（Instance Data）和对其填充（Padding）

### 对象头
对象头包括两个部分的信息
1 用于存储对象自身的运行数据，如哈希码（HashCode），GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等
2 对象头的另一个部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例

### 对象的实例数据
程序代码所定义的各种类型的字段内容

### 对其填充
仅仅起着占位符的作用，并不是必然存在的

## 对象的访问定位
建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中之规定了一个指向对象的引用，
并没有定义应该通过何种方式去定位，访问对中的对象的具体位置。所以对象的访问方式取决于虚拟机的实现。目前主流的访问方式有句柄和直接指针两种
如果使用句柄访问的话，那么Java堆中就会划分一块内存作为句柄池，reference中存储的就是句柄地址，而句柄中包含了对象的实例数据和类型数据的地址信息
如果使用直接指针访问，那么Java堆中的布局就必须考虑如何放置访问类型数据相关的信息。而reference 中存储的直接就是对象地址

两种方式的优势：
  使用句柄的好处就是当对象被移动时，只会改变句柄中的实例数据指针
  使用直接指针访问最大的好处就是快，节约了一次指针定位的时间开销
