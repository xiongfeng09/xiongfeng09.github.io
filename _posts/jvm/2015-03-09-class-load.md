---
layout: post
title: jvm-class-load
category: jvm
tags: jvm
description: 类加载机制
---

# 类记载的时机
类加载的生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接

5种情况下会对类进行初始化
1 遇到new，getstatic, putstatic 或 invokestatic
2 使用java.lang.reflect包的方法对类进行反射调用
3 当初始化一个类的时候发现其父类还没有初始化
4 当虚拟机启动的时候，需要执行一个main方法，会初始化这个主类
5 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化

# 类加载的过程
在加载过程中，虚拟机需要完成以下三件事情
1 通过一个类的全限定名来获得定义此类的二进制字节流
2 将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构
3 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

一个非数组类的加载阶段是开发人员可控性最强的。因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。

对于数组而言。数据本身不通过类加载器完成，它是由java虚拟机直接创建的。但数组类与类加载器仍让有密切的关系，因为数据类的元素类型（ElementType,指的是数据去掉所有维度的类型）

# 验证
## 文件格式验证
是否以Magic Number `0xCAFEBABE` 开头
主次版本号是否在当前虚拟机处理范围之内
常量池中的常量是否有不被支持的常量类型（检查常量tag标志）
指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量
CONSTANT_Utf8_info 型的常量中是否有不符合UTF8编码的数据
......等等

这个阶段的验证是基于二进制流的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的阶段都是基于方法去的存储结构进行的，不会在直接操作字节流。
## 元数据验证
这个类是否有父类（出java.lang.Object 之外，所有的类都应该有父类）
这个类是否继承了不允许继承的类。如final类
如果这个类不是抽象的，是否实现了父类或借口中要求实现的所有方法
类中的字段和方法是否和父类中的产生了矛盾（出现了不符合规则的方法重载等）

这个阶段主要是对类的语义验证，保证不存在不符合Java语言规范的元数据信息
## 字节码验证
这个阶段是最复杂的，主要是通过数据流和控制流分析，确定程序语义是否合法，符合逻辑的。

## 符号引用验证
最后一个阶段发生在虚拟机将符号引用转换为直接引用的时候
交验以下内容
  符号引用中通过字符串描述的全限定名是否能找到对应的类。
  在指定类中是否存在符号方法的字段描述符以及简单名称所描述的字段和方法。
  符号引用中的类，字段和方法的访问性是否可被当前类访问

# 准备
准备阶段是正是为类变量分配内存并设置类变量初始值阶段，这些变量所使用的内存都将在方法去中进行分配。
通常情况下这个阶段进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量
实例变量将会在对象实例化时随着对象一起分配在java堆中。

```
pulic static int value = 123;
```

value 在准备阶段过后的初始值为0而不是123，因为这个时候还没有开始执行任何java方法
而把value赋值为123的putstatic指令是在程序被编译后，存放于类构造器<clinit>()中，所以复制在初始化阶段才会执行

特别情况

```
public static final int value = 123;
```
如果类字段的字段属性表中存在`Constant Value`属性，那么在准备阶段变量value就会被初始化
# 解析
解析阶段是虚拟机将常量池内符号引用替换为直接饮用的过程

符号引用（Symbolic Reference）:符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存。
直接饮用（Direct Reference）:直接引用可以是直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。
## 类接口解析
## 字段解析
## 类方法解析
## 接口方法解析

# 初始化
类初始化是类加载过程的最后一步，在初始化阶段，根据程序员通过程序指定的主观计划去初始化变量和其他资源。

<clinit>()方法是由编译器自动收集的所有类变量的赋值动作和静态语句块中的语句合并产生的。
与类的构造函数不同，他不需要显示的调用父类的构造器，虚拟机会保证子类的<clinit>()方法执行之前，父类的已经执行完毕。

父类中定义的静态语句快先执行

<clinit>()方法对于类或者接口来说不是必须的。所以一个类或者接口如果没有静态语句话块，那么编译器也不会生成改方法

接口中不能使用静态语句块，但也有变量的初始化赋值操作。接口与类不同的是：
 接口的clinit方法不要先执行父接口的，只有当父接口中定义的变量被使用时才会初始化
 接口的实现类在初始化的时候一样不会执行接口的clinit方法
 
虚拟机会抱枕给一个类的clinit方法在多线程中被正确的加锁，同步。
# 类加载器
## 类与类加载器
对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个加载器都拥有独立的类名称空间。
通俗一点的说： 比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义。
## 双亲委派模型
## 破坏双亲委派模型